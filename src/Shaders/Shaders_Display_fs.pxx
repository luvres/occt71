// This file has been automatically generated from resource file src/Shaders/Display.fs

static const char Shaders_Display_fs[] =
  "#ifdef ADAPTIVE_SAMPLING\n"
  "\n"
  "  #extension GL_ARB_shader_image_load_store : require\n"
  "\n"
  "  //! OpenGL image used for accumulating rendering result.\n"
  "  volatile restrict layout(size1x32) uniform image2D uRenderImage;\n"
  "\n"
  "  //! OpenGL image storing variance of sampled pixels blocks.\n"
  "  volatile restrict layout(size1x32) uniform iimage2D uVarianceImage;\n"
  "\n"
  "#else // ADAPTIVE_SAMPLING\n"
  "\n"
  "  //! Input image.\n"
  "  uniform sampler2D uInputTexture;\n"
  "\n"
  "  //! Ray tracing depth image.\n"
  "  uniform sampler2D uDepthTexture;\n"
  "\n"
  "#endif // ADAPTIVE_SAMPLING\n"
  "\n"
  "//! Number of accumulated frames.\n"
  "uniform int uAccumFrames;\n"
  "\n"
  "//! Is debug mode enabled for importance screen sampling.\n"
  "uniform int uDebugAdaptive;\n"
  "\n"
  "//! Output pixel color.\n"
  "out vec4 OutColor;\n"
  "\n"
  "//! RGB weight factors to calculate luminance.\n"
  "#define LUMA vec3 (0.2126f, 0.7152f, 0.0722f)\n"
  "\n"
  "//! Scale factor used to quantize visual error.\n"
  "#define SCALE_FACTOR 1.0e6f\n"
  "\n"
  "// =======================================================================\n"
  "// function : main\n"
  "// purpose  :\n"
  "// =======================================================================\n"
  "void main (void)\n"
  "{\n"
  "#ifndef ADAPTIVE_SAMPLING\n"
  "\n"
  "  vec4 aColor = texelFetch (uInputTexture, ivec2 (gl_FragCoord.xy), 0);\n"
  "\n"
  "#ifdef PATH_TRACING\n"
  "  float aDepth = aColor.w; // path tracing uses averaged depth\n"
  "#else\n"
  "  float aDepth = texelFetch (uDepthTexture, ivec2 (gl_FragCoord.xy), 0).r;\n"
  "#endif\n"
  "\n"
  "  gl_FragDepth = aDepth;\n"
  "\n"
  "#else // ADAPTIVE_SAMPLING\n"
  "\n"
  "  ivec2 aPixel = ivec2 (gl_FragCoord.xy);\n"
  "\n"
  "  vec4 aColor = vec4 (0.0);\n"
  "\n"
  "  // fetch accumulated color and total number of samples\n"
  "  aColor.x = imageLoad (uRenderImage, ivec2 (3 * aPixel.x + 0,\n"
  "                                             2 * aPixel.y + 0)).x;\n"
  "  aColor.y = imageLoad (uRenderImage, ivec2 (3 * aPixel.x + 1,\n"
  "                                             2 * aPixel.y + 0)).x;\n"
  "  aColor.z = imageLoad (uRenderImage, ivec2 (3 * aPixel.x + 1,\n"
  "                                             2 * aPixel.y + 1)).x;\n"
  "  aColor.w = imageLoad (uRenderImage, ivec2 (3 * aPixel.x + 0,\n"
  "                                             2 * aPixel.y + 1)).x;\n"
  "\n"
  "  // calculate normalization factor\n"
  "  float aSampleWeight = 1.f / max (1.0, aColor.w);\n"
  "\n"
  "  // calculate averaged depth value\n"
  "  gl_FragDepth = imageLoad (uRenderImage, ivec2 (3 * aPixel.x + 2,\n"
  "                                                 2 * aPixel.y + 1)).x * aSampleWeight;\n"
  "\n"
  "  // calculate averaged radiance for all samples and even samples only\n"
  "  float aHalfRad = imageLoad (uRenderImage, ivec2 (3 * aPixel.x + 2,\n"
  "                                                   2 * aPixel.y + 0)).x * aSampleWeight * 2.f;\n"
  "\n"
  "  float aAverRad = dot (aColor.rgb, LUMA) * aSampleWeight;\n"
  "\n"
  "  // apply our 'tone mapping' operator (gamma correction and clamping)\n"
  "  aHalfRad = min (1.f, sqrt (aHalfRad));\n"
  "  aAverRad = min (1.f, sqrt (aAverRad));\n"
  "\n"
  "  // calculate visual error\n"
  "  float anError = (aAverRad - aHalfRad) * (aAverRad - aHalfRad);\n"
  "\n"
  "  // accumulate visual error to current block\n"
  "  imageAtomicAdd (uVarianceImage, ivec2 (aPixel / vec2 (BLOCK_SIZE)), int (anError * SCALE_FACTOR));\n"
  "\n"
  "  if (uDebugAdaptive == 0) // normal rendering\n"
  "  {\n"
  "    aColor = vec4 (aColor.rgb * aSampleWeight, 1.0);\n"
  "  }\n"
  "  else // showing number of samples\n"
  "  {\n"
  "    aColor = vec4 (0.5f * aColor.rgb * aSampleWeight + vec3 (0.f, aColor.w / uAccumFrames * 0.35f, 0.f), 1.0);\n"
  "  }\n"
  "\n"
  "#endif // ADAPTIVE_SAMPLING\n"
  "\n"
  "#ifdef PATH_TRACING\n"
  "\n"
  "   // apply gamma correction (we use gamma = 2)\n"
  "   OutColor = vec4 (sqrt (aColor.rgb), 0.f);\n"
  "\n"
  "#else // not PATH_TRACING\n"
  "\n"
  "   OutColor = aColor;\n"
  "\n"
  "#endif\n"
  "}\n";
