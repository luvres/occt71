// This file has been automatically generated from resource file src/Shaders/PathtraceBase.fs

static const char Shaders_PathtraceBase_fs[] =
  "#ifdef _MSC_VER\n"
  "  #define PATH_TRACING // just for editing in MS VS\n"
  "\n"
  "  #define in\n"
  "  #define out\n"
  "  #define inout\n"
  "\n"
  "  typedef struct { float x; float y; } vec2;\n"
  "  typedef struct { float x; float y; float z; } vec3;\n"
  "  typedef struct { float x; float y; float z; float w; } vec4;\n"
  "#endif\n"
  "\n"
  "#ifdef PATH_TRACING\n"
  "\n"
  "//! Number of previously rendered frames.\n"
  "uniform int uAccumSamples;\n"
  "\n"
  "///////////////////////////////////////////////////////////////////////////////////////\n"
  "// Specific data types\n"
  "\n"
  "//! Describes local space at the hit point (visualization space).\n"
  "struct SLocalSpace\n"
  "{\n"
  "  //! Local X axis.\n"
  "  vec3 AxisX;\n"
  "\n"
  "  //! Local Y axis.\n"
  "  vec3 AxisY;\n"
  "\n"
  "  //! Local Z axis.\n"
  "  vec3 AxisZ;\n"
  "};\n"
  "\n"
  "//! Describes material properties (BSDF).\n"
  "struct SMaterial\n"
  "{\n"
  "  //! Weight of the Lambertian BRDF.\n"
  "  vec4 Kd;\n"
  "\n"
  "  //! Weight of the reflection BRDF.\n"
  "  vec3 Kr;\n"
  "\n"
  "  //! Weight of the transmission BTDF.\n"
  "  vec3 Kt;\n"
  "\n"
  "  //! Weight of the Blinn BRDF (and roughness).\n"
  "  vec4 Ks;\n"
  "\n"
  "  //! Fresnel coefficients.\n"
  "  vec3 Fresnel;\n"
  "\n"
  "  //! Absorption color and intensity of the media.\n"
  "  vec4 Absorption;\n"
  "};\n"
  "\n"
  "///////////////////////////////////////////////////////////////////////////////////////\n"
  "// Support subroutines\n"
  "\n"
  "//=======================================================================\n"
  "// function : buildLocalSpace\n"
  "// purpose  : Generates local space for the given normal\n"
  "//=======================================================================\n"
  "SLocalSpace buildLocalSpace (in vec3 theNormal)\n"
  "{\n"
  "  vec3 anAxisX = vec3 (theNormal.z, 0.f, -theNormal.x);\n"
  "  vec3 anAxisY = vec3 (0.f, -theNormal.z, theNormal.y);\n"
  "\n"
  "  float aSqrLenX = dot (anAxisX, anAxisX);\n"
  "  float aSqrLenY = dot (anAxisY, anAxisY);\n"
  "\n"
  "  if (aSqrLenX > aSqrLenY)\n"
  "  {\n"
  "    anAxisX *= inversesqrt (aSqrLenX);\n"
  "    anAxisY = cross (anAxisX, theNormal);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    anAxisY *= inversesqrt (aSqrLenY);\n"
  "    anAxisX = cross (anAxisY, theNormal);\n"
  "  }\n"
  "\n"
  "  return SLocalSpace (anAxisX, anAxisY, theNormal);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : toLocalSpace\n"
  "// purpose  : Transforms the vector to local space from world space\n"
  "//=======================================================================\n"
  "vec3 toLocalSpace (in vec3 theVector, in SLocalSpace theSpace)\n"
  "{\n"
  "  return vec3 (dot (theVector, theSpace.AxisX),\n"
  "               dot (theVector, theSpace.AxisY),\n"
  "               dot (theVector, theSpace.AxisZ));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fromLocalSpace\n"
  "// purpose  : Transforms the vector from local space to world space\n"
  "//=======================================================================\n"
  "vec3 fromLocalSpace (in vec3 theVector, in SLocalSpace theSpace)\n"
  "{\n"
  "  return theVector.x * theSpace.AxisX +\n"
  "         theVector.y * theSpace.AxisY +\n"
  "         theVector.z * theSpace.AxisZ;\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : convolve\n"
  "// purpose  : Performs a linear convolution of the vector components\n"
  "//=======================================================================\n"
  "float convolve (in vec3 theVector, in vec3 theFactor)\n"
  "{\n"
  "  return dot (theVector, theFactor) * (1.f / max (theFactor.x + theFactor.y + theFactor.z, 1e-15f));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelSchlick\n"
  "// purpose  : Computes the Fresnel reflection formula using\n"
  "//            Schlick's approximation.\n"
  "//=======================================================================\n"
  "vec3 fresnelSchlick (in float theCosI, in vec3 theSpecularColor)\n"
  "{\n"
  "  return theSpecularColor + (UNIT - theSpecularColor) * pow (1.f - theCosI, 5.f);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelDielectric\n"
  "// purpose  : Computes the Fresnel reflection formula for dielectric in\n"
  "//            case of circularly polarized light (Based on PBRT code).\n"
  "//=======================================================================\n"
  "float fresnelDielectric (in float theCosI,\n"
  "                         in float theCosT,\n"
  "                         in float theEtaI,\n"
  "                         in float theEtaT)\n"
  "{\n"
  "  float aParl = (theEtaT * theCosI - theEtaI * theCosT) /\n"
  "                (theEtaT * theCosI + theEtaI * theCosT);\n"
  "\n"
  "  float aPerp = (theEtaI * theCosI - theEtaT * theCosT) /\n"
  "                (theEtaI * theCosI + theEtaT * theCosT);\n"
  "\n"
  "  return (aParl * aParl + aPerp * aPerp) * 0.5f;\n"
  "}\n"
  "\n"
  "#define ENVIRONMENT_IOR 1.f\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelDielectric\n"
  "// purpose  : Computes the Fresnel reflection formula for dielectric in\n"
  "//            case of circularly polarized light (based on PBRT code)\n"
  "//=======================================================================\n"
  "float fresnelDielectric (in float theCosI, in float theIndex)\n"
  "{\n"
  "  float anEtaI = theCosI > 0.f ? 1.f : theIndex;\n"
  "  float anEtaT = theCosI > 0.f ? theIndex : 1.f;\n"
  "\n"
  "  float aSinT = (anEtaI / anEtaT) * sqrt (1.f - theCosI * theCosI);\n"
  "\n"
  "  if (aSinT >= 1.f)\n"
  "  {\n"
  "    return 1.f;\n"
  "  }\n"
  "\n"
  "  float aCosT = sqrt (1.f - aSinT * aSinT);\n"
  "\n"
  "  return fresnelDielectric (abs (theCosI), aCosT, anEtaI, anEtaT);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelConductor\n"
  "// purpose  : Computes the Fresnel reflection formula for conductor in case\n"
  "//            of circularly polarized light (based on PBRT source code)\n"
  "//=======================================================================\n"
  "float fresnelConductor (in float theCosI, in float theEta, in float theK)\n"
  "{\n"
  "  float aTmp = 2.f * theEta * theCosI;\n"
  "\n"
  "  float aTmp1 = theEta * theEta + theK * theK;\n"
  "\n"
  "  float aSPerp = (aTmp1 - aTmp + theCosI * theCosI) /\n"
  "                 (aTmp1 + aTmp + theCosI * theCosI);\n"
  "\n"
  "  float aTmp2 = aTmp1 * theCosI * theCosI;\n"
  "\n"
  "  float aSParl = (aTmp2 - aTmp + 1.f) /\n"
  "                 (aTmp2 + aTmp + 1.f);\n"
  "\n"
  "  return (aSPerp + aSParl) * 0.5f;\n"
  "}\n"
  "\n"
  "#define FRESNEL_SCHLICK    -0.5f\n"
  "#define FRESNEL_CONSTANT   -1.5f\n"
  "#define FRESNEL_CONDUCTOR  -2.5f\n"
  "#define FRESNEL_DIELECTRIC -3.5f\n"
  "\n"
  "//=======================================================================\n"
  "// function : fresnelMedia\n"
  "// purpose  : Computes the Fresnel reflection formula for general medium\n"
  "//            in case of circularly polarized light.\n"
  "//=======================================================================\n"
  "vec3 fresnelMedia (in float theCosI, in vec3 theFresnel)\n"
  "{\n"
  "  if (theFresnel.x > FRESNEL_SCHLICK)\n"
  "  {\n"
  "    return fresnelSchlick (abs (theCosI), theFresnel);\n"
  "  }\n"
  "\n"
  "  if (theFresnel.x > FRESNEL_CONSTANT)\n"
  "  {\n"
  "    return vec3 (theFresnel.z);\n"
  "  }\n"
  "\n"
  "  if (theFresnel.x > FRESNEL_CONDUCTOR)\n"
  "  {\n"
  "    return vec3 (fresnelConductor (abs (theCosI), theFresnel.y, theFresnel.z));\n"
  "  }\n"
  "\n"
  "  return vec3 (fresnelDielectric (theCosI, theFresnel.y));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : transmitted\n"
  "// purpose  : Computes transmitted direction in tangent space\n"
  "//            (in case of TIR returned result is undefined!)\n"
  "//=======================================================================\n"
  "void transmitted (in float theIndex, in vec3 theIncident, out vec3 theTransmit)\n"
  "{\n"
  "  // Compute relative index of refraction\n"
  "  float anEta = (theIncident.z > 0.f) ? 1.f / theIndex : theIndex;\n"
  "\n"
  "  // Handle total internal reflection (TIR)\n"
  "  float aSinT2 = anEta * anEta * (1.f - theIncident.z * theIncident.z);\n"
  "\n"
  "  // Compute direction of transmitted ray\n"
  "  float aCosT = sqrt (1.f - min (aSinT2, 1.f)) * sign (-theIncident.z);\n"
  "\n"
  "  theTransmit = normalize (vec3 (-anEta * theIncident.x,\n"
  "                                 -anEta * theIncident.y,\n"
  "                                  aCosT));\n"
  "}\n"
  "\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "// Handlers and samplers for materials\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "\n"
  "//=======================================================================\n"
  "// function : HandleLambertianReflection\n"
  "// purpose  : Handles Lambertian BRDF, with cos(N, PSI)\n"
  "//=======================================================================\n"
  "float HandleLambertianReflection (in vec3 theInput, in vec3 theOutput)\n"
  "{\n"
  "  return (theInput.z <= 0.f || theOutput.z <= 0.f) ? 0.f : theInput.z * (1.f / M_PI);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : SmithG1\n"
  "// purpose  :\n"
  "//=======================================================================\n"
  "float SmithG1 (in vec3 theDirection, in vec3 theM, in float theRoughness)\n"
  "{\n"
  "  if (dot (theDirection, theM) * theDirection.z <= 0.f)\n"
  "  {\n"
  "    return 0.f;\n"
  "  }\n"
  "\n"
  "  float aTanThetaM = sqrt (1.f - theDirection.z * theDirection.z) / theDirection.z;\n"
  "\n"
  "  if (aTanThetaM == 0.0f)\n"
  "  {\n"
  "    return 1.f;\n"
  "  }\n"
  "\n"
  "  float aVal = 1.f / (theRoughness * aTanThetaM);\n"
  "\n"
  "  if (aVal >= 1.6f)\n"
  "  {\n"
  "    return 1.f;\n"
  "  }\n"
  "\n"
  "  // Use fast and accurate rational approximation to the\n"
  "  // shadowing-masking function (from Mitsuba renderer)\n"
  "  float aSqr = aVal * aVal;\n"
  "\n"
  "  return (3.535f * aVal + 2.181f * aSqr) / (1.f + 2.276f * aVal + 2.577f * aSqr);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : HandleBlinnReflection\n"
  "// purpose  : Handles Blinn glossy BRDF, with cos(N, PSI)\n"
  "//=======================================================================\n"
  "vec3 HandleBlinnReflection (in vec3 theInput, in vec3 theOutput, in vec3 theFresnel, in float theRoughness)\n"
  "{\n"
  "  // calculate the reflection half-vec\n"
  "  vec3 aH = normalize (theInput + theOutput);\n"
  "\n"
  "  // roughness value -> Blinn exponent\n"
  "  float aPower = max (2.f / (theRoughness * theRoughness) - 2.f, 0.f);\n"
  "\n"
  "  // calculate microfacet distribution\n"
  "  float aD = (aPower + 2.f) * (1.f / M_2_PI) * pow (aH.z, aPower);\n"
  "\n"
  "  // calculate shadow-masking function\n"
  "  float aG = SmithG1 (theOutput, aH, theRoughness) * SmithG1 (theInput, aH, theRoughness);\n"
  "\n"
  "  // return total amount of reflection\n"
  "  return (theInput.z <= 0.f || theOutput.z <= 0.f) ? ZERO :\n"
  "    aD * aG / (4.f * theOutput.z) * fresnelMedia (dot (theOutput, aH), theFresnel);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : HandleMaterial\n"
  "// purpose  : Returns BSDF value for specified material, with cos(N, PSI)\n"
  "//=======================================================================\n"
  "vec3 HandleMaterial (in SMaterial theBSDF, in vec3 theInput, in vec3 theOutput)\n"
  "{\n"
  "  return theBSDF.Kd.rgb * HandleLambertianReflection (theInput, theOutput) +\n"
  "    theBSDF.Ks.rgb * HandleBlinnReflection (theInput, theOutput, theBSDF.Fresnel, theBSDF.Ks.w);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : SampleLambertianReflection\n"
  "// purpose  : Samples Lambertian BRDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//=======================================================================\n"
  "vec3 SampleLambertianReflection (in vec3 theOutput, out vec3 theInput, inout float thePDF)\n"
  "{\n"
  "  float aKsi1 = RandFloat();\n"
  "  float aKsi2 = RandFloat();\n"
  "\n"
  "  float aTemp = sqrt (aKsi2);\n"
  "\n"
  "  theInput = vec3 (aTemp * cos (M_2_PI * aKsi1),\n"
  "                   aTemp * sin (M_2_PI * aKsi1),\n"
  "                   sqrt (1.f - aKsi2));\n"
  "\n"
  "  thePDF *= abs (theInput.z) * (1.f / M_PI);\n"
  "\n"
  "  return (theInput.z <= 0.f || theOutput.z <= 0.f) ? ZERO : UNIT;\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : SampleBlinnReflection\n"
  "// purpose  : Samples Blinn BRDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//            The BRDF is a product of three main terms, D, G, and F,\n"
  "//            which is then divided by two cosine terms. Here we perform\n"
  "//            importance sample the D part of the Blinn model; trying to\n"
  "//            develop a sampling procedure that accounted for all of the\n"
  "//            terms would be complex, and it is the D term that accounts\n"
  "//            for most of the variation.\n"
  "//=======================================================================\n"
  "vec3 SampleBlinnReflection (in vec3 theOutput, out vec3 theInput, in vec3 theFresnel, in float theRoughness, inout float thePDF)\n"
  "{\n"
  "  float aKsi1 = RandFloat();\n"
  "  float aKsi2 = RandFloat();\n"
  "\n"
  "  // roughness value --> Blinn exponent\n"
  "  float aPower = max (2.f / (theRoughness * theRoughness) - 2.f, 0.f);\n"
  "\n"
  "  // normal from microface distribution\n"
  "  float aCosThetaM = pow (aKsi1, 1.f / (aPower + 2.f));\n"
  "\n"
  "  vec3 aM = vec3 (cos (M_2_PI * aKsi2),\n"
  "                  sin (M_2_PI * aKsi2),\n"
  "                  aCosThetaM);\n"
  "\n"
  "  aM.xy *= sqrt (1.f - aCosThetaM * aCosThetaM);\n"
  "\n"
  "  // calculate PDF of sampled direction\n"
  "  thePDF *= (aPower + 2.f) * (1.f / M_2_PI) * pow (aCosThetaM, aPower + 1.f);\n"
  "\n"
  "  float aCosDelta = dot (theOutput, aM);\n"
  "\n"
  "  // pick input based on half direction\n"
  "  theInput = -theOutput + 2.f * aCosDelta * aM;\n"
  "\n"
  "  if (theInput.z <= 0.f || theOutput.z <= 0.f)\n"
  "  {\n"
  "    return ZERO;\n"
  "  }\n"
  "\n"
  "  // Jacobian of half-direction mapping\n"
  "  thePDF /= 4.f * dot (theInput, aM);\n"
  "\n"
  "  // compute shadow-masking coefficient\n"
  "  float aG = SmithG1 (theOutput, aM, theRoughness) * SmithG1 (theInput, aM, theRoughness);\n"
  "\n"
  "  return aG * aCosDelta / (theOutput.z * aM.z) * fresnelMedia (aCosDelta, theFresnel);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : SampleSpecularReflection\n"
  "// purpose  : Samples specular BRDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//=======================================================================\n"
  "vec3 SampleSpecularReflection (in vec3 theOutput, out vec3 theInput, in vec3 theFresnel)\n"
  "{\n"
  "  // Sample input direction\n"
  "  theInput = vec3 (-theOutput.x,\n"
  "                   -theOutput.y,\n"
  "                    theOutput.z);\n"
  "\n"
  "  return fresnelMedia (theOutput.z, theFresnel);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : SampleSpecularTransmission\n"
  "// purpose  : Samples specular BTDF, W = BRDF * cos(N, PSI) / PDF(PSI)\n"
  "//=======================================================================\n"
  "vec3 SampleSpecularTransmission (in vec3 theOutput,\n"
  "  out vec3 theInput, in vec3 theWeight, in vec3 theFresnel, inout bool theInside)\n"
  "{\n"
  "  vec3 aFactor = fresnelMedia (theOutput.z, theFresnel);\n"
  "\n"
  "  float aReflection = convolve (aFactor, theWeight);\n"
  "\n"
  "  // sample specular BRDF/BTDF\n"
  "  if (RandFloat() <= aReflection)\n"
  "  {\n"
  "    theInput = vec3 (-theOutput.x,\n"
  "                     -theOutput.y,\n"
  "                      theOutput.z);\n"
  "\n"
  "    theWeight = aFactor * (1.f / aReflection);\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    theInside = !theInside;\n"
  "\n"
  "    transmitted (theFresnel.y, theOutput, theInput);\n"
  "\n"
  "    theWeight = (UNIT - aFactor) * (1.f / (1.f - aReflection));\n"
  "  }\n"
  "\n"
  "  return theWeight;\n"
  "}\n"
  "\n"
  "#define FLT_EPSILON 1.0e-5F\n"
  "\n"
  "//=======================================================================\n"
  "// function : BsdfPdf\n"
  "// purpose  : Calculates BSDF of sampling input knowing output\n"
  "//=======================================================================\n"
  "float BsdfPdf (in SMaterial theBSDF,\n"
  "               in vec3      theOutput,\n"
  "               in vec3      theInput,\n"
  "               in vec3      theWeight)\n"
  "{\n"
  "  float aPd = convolve (theBSDF.Kd.rgb, theWeight);\n"
  "  float aPs = convolve (theBSDF.Ks.rgb, theWeight);\n"
  "  float aPr = convolve (theBSDF.Kr.rgb, theWeight);\n"
  "  float aPt = convolve (theBSDF.Kt.rgb, theWeight);\n"
  "\n"
  "  float aReflection = aPd + aPs + aPr + aPt;\n"
  "\n"
  "  float aPDF = 0.f; // PDF of sampling input direction\n"
  "\n"
  "  if (theInput.z * theOutput.z > 0.f)\n"
  "  {\n"
  "    vec3 aHalf = normalize (theInput + theOutput);\n"
  "\n"
  "    // roughness value --> Blinn exponent\n"
  "    float aPower = max (2.f / (theBSDF.Ks.w * theBSDF.Ks.w) - 2.f, 0.f);\n"
  "\n"
  "    aPDF = aPd * abs (theInput.z / M_PI) +\n"
  "      aPs * (aPower + 2.f) * (1.f / M_2_PI) * pow (aHalf.z, aPower + 1.f) / (4.f * dot (theInput, aHalf));\n"
  "  }\n"
  "\n"
  "  return aPDF / aReflection;\n"
  "}\n"
  "\n"
  "//! Tool macro to handle sampling of particular BxDF\n"
  "#define PICK_BXDF(p, k) aPDF = p / aReflection; theWeight *= k / aPDF;\n"
  "\n"
  "//=======================================================================\n"
  "// function : SampleBsdf\n"
  "// purpose  : Samples specified composite material (BSDF)\n"
  "//=======================================================================\n"
  "float SampleBsdf (in SMaterial theBSDF,\n"
  "                  in vec3      theOutput,\n"
  "                  out vec3     theInput,\n"
  "                  inout vec3   theWeight,\n"
  "                  inout bool   theInside)\n"
  "{\n"
  "  // compute probability of each reflection type (BxDF)\n"
  "  float aPd = convolve (theBSDF.Kd.rgb, theWeight);\n"
  "  float aPs = convolve (theBSDF.Ks.rgb, theWeight);\n"
  "  float aPr = convolve (theBSDF.Kr.rgb, theWeight);\n"
  "  float aPt = convolve (theBSDF.Kt.rgb, theWeight);\n"
  "\n"
  "  float aReflection = aPd + aPs + aPr + aPt;\n"
  "\n"
  "  // choose BxDF component to sample\n"
  "  float aKsi = aReflection * RandFloat();\n"
  "\n"
  "  // BxDF's PDF of sampled direction\n"
  "  float aPDF = 0.f;\n"
  "\n"
  "  if (aKsi < aPd) // diffuse reflection\n"
  "  {\n"
  "    PICK_BXDF (aPd, theBSDF.Kd.rgb);\n"
  "\n"
  "    theWeight *= SampleLambertianReflection (theOutput, theInput, aPDF);\n"
  "  }\n"
  "  else if (aKsi < aPd + aPs) // glossy reflection\n"
  "  {\n"
  "    PICK_BXDF (aPs, theBSDF.Ks.rgb);\n"
  "\n"
  "    theWeight *= SampleBlinnReflection (theOutput, theInput, theBSDF.Fresnel, theBSDF.Ks.w, aPDF);\n"
  "  }\n"
  "  else if (aKsi < aPd + aPs + aPr) // specular reflection\n"
  "  {\n"
  "    PICK_BXDF (aPr, theBSDF.Kr.rgb);\n"
  "\n"
  "    aPDF = MAXFLOAT;\n"
  "\n"
  "    theWeight *= SampleSpecularReflection (theOutput, theInput, theBSDF.Fresnel);\n"
  "  }\n"
  "  else if (aKsi < aReflection) // specular transmission\n"
  "  {\n"
  "    PICK_BXDF (aPt, theBSDF.Kt.rgb);\n"
  "\n"
  "    aPDF = MAXFLOAT;\n"
  "\n"
  "    theWeight *= SampleSpecularTransmission (theOutput, theInput, theWeight, theBSDF.Fresnel, theInside);\n"
  "  }\n"
  "\n"
  "  // path termination for extra small weights\n"
  "  theWeight = mix (ZERO, theWeight, step (FLT_EPSILON, aReflection));\n"
  "\n"
  "  return aPDF;\n"
  "}\n"
  "\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "// Handlers and samplers for light sources\n"
  "//////////////////////////////////////////////////////////////////////////////////////////////\n"
  "\n"
  "// =======================================================================\n"
  "// function : Latlong\n"
  "// purpose  : Converts world direction to environment texture coordinates\n"
  "// =======================================================================\n"
  "vec2 Latlong (in vec3 thePoint)\n"
  "{\n"
  "  float aPsi = acos (-thePoint.z);\n"
  "\n"
  "  float aPhi = atan (thePoint.y, thePoint.x) + M_PI;\n"
  "\n"
  "  return vec2 (aPhi * 0.1591549f,\n"
  "               aPsi * 0.3183098f);\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : SampleLight\n"
  "// purpose  : General sampling function for directional and point lights\n"
  "//=======================================================================\n"
  "vec3 SampleLight (in vec3 theToLight, inout float theDistance, in bool isInfinite, in float theSmoothness, inout float thePDF)\n"
  "{\n"
  "  SLocalSpace aSpace = buildLocalSpace (theToLight * (1.f / theDistance));\n"
  "\n"
  "  // for point lights smoothness defines radius\n"
  "  float aCosMax = isInfinite ? theSmoothness :\n"
  "    inversesqrt (1.f + theSmoothness * theSmoothness / (theDistance * theDistance));\n"
  "\n"
  "  float aKsi1 = RandFloat();\n"
  "  float aKsi2 = RandFloat();\n"
  "\n"
  "  float aTmp = 1.f - aKsi2 * (1.f - aCosMax);\n"
  "\n"
  "  vec3 anInput = vec3 (cos (M_2_PI * aKsi1),\n"
  "                       sin (M_2_PI * aKsi1),\n"
  "                       aTmp);\n"
  "\n"
  "  anInput.xy *= sqrt (1.f - aTmp * aTmp);\n"
  "\n"
  "  thePDF = (aCosMax < 1.f) ? (thePDF / M_2_PI) / (1.f - aCosMax) : MAXFLOAT;\n"
  "\n"
  "  return normalize (fromLocalSpace (anInput, aSpace));\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : HandlePointLight\n"
  "// purpose  :\n"
  "//=======================================================================\n"
  "float HandlePointLight (in vec3 theInput, in vec3 theToLight, in float theRadius, in float theDistance, inout float thePDF)\n"
  "{\n"
  "  float aCosMax = inversesqrt (1.f + theRadius * theRadius / (theDistance * theDistance));\n"
  "\n"
  "  float aVisibility = step (aCosMax, dot (theInput, theToLight));\n"
  "\n"
  "  thePDF *= step (-1.f, -aCosMax) * aVisibility * (1.f / M_2_PI) / (1.f - aCosMax);\n"
  "\n"
  "  return aVisibility;\n"
  "}\n"
  "\n"
  "//=======================================================================\n"
  "// function : HandleDistantLight\n"
  "// purpose  :\n"
  "//=======================================================================\n"
  "float HandleDistantLight (in vec3 theInput, in vec3 theToLight, in float theCosMax, inout float thePDF)\n"
  "{\n"
  "  float aVisibility = step (theCosMax, dot (theInput, theToLight));\n"
  "\n"
  "  thePDF *= step (-1.f, -theCosMax) * aVisibility * (1.f / M_2_PI) / (1.f - theCosMax);\n"
  "\n"
  "  return aVisibility;\n"
  "}\n"
  "\n"
  "// =======================================================================\n"
  "// function: IntersectLight\n"
  "// purpose : Checks intersections with light sources\n"
  "// =======================================================================\n"
  "vec3 IntersectLight (in SRay theRay, in int theDepth, in float theHitDistance, out float thePDF)\n"
  "{\n"
  "  vec3 aTotalRadiance = ZERO;\n"
  "\n"
  "  thePDF = 0.f; // PDF of sampling light sources\n"
  "\n"
  "  for (int aLightIdx = 0; aLightIdx < uLightCount; ++aLightIdx)\n"
  "  {\n"
  "    vec4 aLight = texelFetch (\n"
  "      uRaytraceLightSrcTexture, LIGHT_POS (aLightIdx));\n"
  "    vec4 aParam = texelFetch (\n"
  "      uRaytraceLightSrcTexture, LIGHT_PWR (aLightIdx));\n"
  "\n"
  "    // W component: 0 for infinite light and 1 for point light\n"
  "    aLight.xyz -= mix (ZERO, theRay.Origin, aLight.w);\n"
  "\n"
  "    float aPDF = 1.f / uLightCount;\n"
  "\n"
  "    if (aLight.w != 0.f) // point light source\n"
  "    {\n"
  "      float aCenterDst = length (aLight.xyz);\n"
  "\n"
  "      if (aCenterDst < theHitDistance)\n"
  "      {\n"
  "        float aVisibility = HandlePointLight (\n"
  "          theRay.Direct, normalize (aLight.xyz), aParam.w /* radius */, aCenterDst, aPDF);\n"
  "\n"
  "        if (aVisibility > 0.f)\n"
  "        {\n"
  "          theHitDistance = aCenterDst;\n"
  "          aTotalRadiance = aParam.rgb;\n"
  "\n"
  "          thePDF = aPDF;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    else if (theHitDistance == MAXFLOAT) // directional light source\n"
  "    {\n"
  "      aTotalRadiance += aParam.rgb * HandleDistantLight (\n"
  "        theRay.Direct, aLight.xyz, aParam.w /* angle cosine */, aPDF);\n"
  "\n"
  "      thePDF += aPDF;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  if (thePDF == 0.f && theHitDistance == MAXFLOAT) // light source not found\n"
  "  {\n"
  "    if (theDepth + uSphereMapForBack == 0) // view ray and map is hidden\n"
  "    {\n"
  "      aTotalRadiance = pow (BackgroundColor().rgb, vec3 (2.f));\n"
  "    }\n"
  "    else\n"
  "    {\n"
  "      aTotalRadiance = pow (FetchEnvironment (Latlong (theRay.Direct)).rgb, vec3 (2.f));\n"
  "    }\n"
  "  }\n"
  "  \n"
  "  return aTotalRadiance;\n"
  "}\n"
  "\n"
  "#define MIN_THROUGHPUT   vec3 (1.0e-3f)\n"
  "#define MIN_CONTRIBUTION vec3 (1.0e-2f)\n"
  "\n"
  "#define MATERIAL_KD(index)      (18 * index + 11)\n"
  "#define MATERIAL_KR(index)      (18 * index + 12)\n"
  "#define MATERIAL_KT(index)      (18 * index + 13)\n"
  "#define MATERIAL_KS(index)      (18 * index + 14)\n"
  "#define MATERIAL_LE(index)      (18 * index + 15)\n"
  "#define MATERIAL_FRESNEL(index) (18 * index + 16)\n"
  "#define MATERIAL_ABSORPT(index) (18 * index + 17)\n"
  "\n"
  "// Enables expiremental russian roulette sampling\n"
  "#define RUSSIAN_ROULETTE\n"
  "\n"
  "//! Frame step to increase number of bounces\n"
  "#define FRAME_STEP 5\n"
  "\n"
  "//=======================================================================\n"
  "// function : PathTrace\n"
  "// purpose  : Calculates radiance along the given ray\n"
  "//=======================================================================\n"
  "vec4 PathTrace (in SRay theRay, in vec3 theInverse)\n"
  "{\n"
  "  float aRaytraceDepth = MAXFLOAT;\n"
  "\n"
  "  vec3 aRadiance   = ZERO;\n"
  "  vec3 aThroughput = UNIT;\n"
  "\n"
  "  int  aTransfID = 0;     // ID of object transformation\n"
  "  bool aInMedium = false; // is the ray inside an object\n"
  "\n"
  "  float aExpPDF = 1.f;\n"
  "  float aImpPDF = 1.f;\n"
  "\n"
  "  for (int aDepth = 0; aDepth < NB_BOUNCES; ++aDepth)\n"
  "  {\n"
  "    SIntersect aHit = SIntersect (MAXFLOAT, vec2 (ZERO), ZERO);\n"
  "\n"
  "    ivec4 aTriIndex = SceneNearestHit (theRay, theInverse, aHit, aTransfID);\n"
  "\n"
  "    // check implicit path\n"
  "    vec3 aLe = IntersectLight (theRay, aDepth, aHit.Time, aExpPDF);\n"
  "\n"
  "    if (any (greaterThan (aLe, ZERO)) || aTriIndex.x == -1)\n"
  "    {\n"
  "      float aMIS = (aDepth == 0 || aImpPDF == MAXFLOAT) ? 1.f :\n"
  "        aImpPDF * aImpPDF / (aExpPDF * aExpPDF + aImpPDF * aImpPDF);\n"
  "\n"
  "      aRadiance += aThroughput * aLe * aMIS; break; // terminate path\n"
  "    }\n"
  "\n"
  "    vec3 aInvTransf0 = texelFetch (uSceneTransformTexture, aTransfID + 0).xyz;\n"
  "    vec3 aInvTransf1 = texelFetch (uSceneTransformTexture, aTransfID + 1).xyz;\n"
  "    vec3 aInvTransf2 = texelFetch (uSceneTransformTexture, aTransfID + 2).xyz;\n"
  "\n"
  "    // compute geometrical normal\n"
  "    aHit.Normal = normalize (vec3 (dot (aInvTransf0, aHit.Normal),\n"
  "                                   dot (aInvTransf1, aHit.Normal),\n"
  "                                   dot (aInvTransf2, aHit.Normal)));\n"
  "\n"
  "    theRay.Origin += theRay.Direct * aHit.Time; // get new intersection point\n"
  "\n"
  "    // evaluate depth on first hit\n"
  "    if (aDepth == 0)\n"
  "    {\n"
  "      vec4 aNDCPoint = uViewMat * vec4 (theRay.Origin, 1.f);\n"
  "\n"
  "      float aPolygonOffset = PolygonOffset (aHit.Normal, theRay.Origin);\n"
  "      aRaytraceDepth = (aNDCPoint.z / aNDCPoint.w + aPolygonOffset * POLYGON_OFFSET_SCALE) * 0.5f + 0.5f;\n"
  "    }\n"
  "\n"
  "    // fetch material (BSDF)\n"
  "    SMaterial aMaterial = SMaterial (\n"
  "      vec4 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KD      (aTriIndex.w))),\n"
  "      vec3 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KR      (aTriIndex.w))),\n"
  "      vec3 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KT      (aTriIndex.w))),\n"
  "      vec4 (texelFetch (uRaytraceMaterialTexture, MATERIAL_KS      (aTriIndex.w))),\n"
  "      vec3 (texelFetch (uRaytraceMaterialTexture, MATERIAL_FRESNEL (aTriIndex.w))),\n"
  "      vec4 (texelFetch (uRaytraceMaterialTexture, MATERIAL_ABSORPT (aTriIndex.w))));\n"
  "\n"
  "#ifdef USE_TEXTURES\n"
  "    if (aMaterial.Kd.w >= 0.f)\n"
  "    {\n"
  "      vec4 aTexCoord = vec4 (SmoothUV (aHit.UV, aTriIndex), 0.f, 1.f);\n"
  "\n"
  "      vec4 aTrsfRow1 = texelFetch (\n"
  "        uRaytraceMaterialTexture, MATERIAL_TRS1 (aTriIndex.w));\n"
  "      vec4 aTrsfRow2 = texelFetch (\n"
  "        uRaytraceMaterialTexture, MATERIAL_TRS2 (aTriIndex.w));\n"
  "\n"
  "      aTexCoord.st = vec2 (dot (aTrsfRow1, aTexCoord),\n"
  "                           dot (aTrsfRow2, aTexCoord));\n"
  "\n"
  "      vec4 aTexColor = textureLod (\n"
  "        sampler2D (uTextureSamplers[int (aMaterial.Kd.w)]), aTexCoord.st, 0.f);\n"
  "\n"
  "      aMaterial.Kd.rgb *= (aTexColor.rgb, aTexColor.rgb) * aTexColor.w; // de-gamma correction (for gamma = 2)\n"
  "\n"
  "      if (aTexColor.w != 1.0f)\n"
  "      {\n"
  "        // mix transparency BTDF with texture alpha-channel\n"
  "        aMaterial.Kt = (UNIT - aTexColor.www) + aTexColor.w * aMaterial.Kt;\n"
  "      }\n"
  "    }\n"
  "#endif\n"
  "\n"
  "    // compute smooth normal\n"
  "    vec3 aNormal = SmoothNormal (aHit.UV, aTriIndex);\n"
  "\n"
  "    aNormal = normalize (vec3 (dot (aInvTransf0, aNormal),\n"
  "                               dot (aInvTransf1, aNormal),\n"
  "                               dot (aInvTransf2, aNormal)));\n"
  "\n"
  "    SLocalSpace aSpace = buildLocalSpace (aNormal);\n"
  "\n"
  "    // account for self-emission (not stored in the material)\n"
  "    aRadiance += aThroughput * texelFetch (\n"
  "      uRaytraceMaterialTexture, MATERIAL_LE (aTriIndex.w)).rgb;\n"
  "\n"
  "    if (uLightCount > 0 && convolve (aMaterial.Kd.rgb + aMaterial.Ks.rgb, aThroughput) > 0.f)\n"
  "    {\n"
  "      aExpPDF = 1.f / uLightCount;\n"
  "\n"
  "      int aLightIdx = min (int (floor (RandFloat() * uLightCount)), uLightCount - 1);\n"
  "\n"
  "      vec4 aLight = texelFetch (\n"
  "        uRaytraceLightSrcTexture, LIGHT_POS (aLightIdx));\n"
  "      vec4 aParam = texelFetch (\n"
  "        uRaytraceLightSrcTexture, LIGHT_PWR (aLightIdx));\n"
  "\n"
  "      // 'w' component is 0 for infinite light and 1 for point light\n"
  "      aLight.xyz -= mix (ZERO, theRay.Origin, aLight.w);\n"
  "\n"
  "      float aDistance = length (aLight.xyz);\n"
  "\n"
  "      aLight.xyz = SampleLight (aLight.xyz, aDistance,\n"
  "        aLight.w == 0.f /* is infinite */, aParam.w /* max cos or radius */, aExpPDF);\n"
  "\n"
  "      aImpPDF = BsdfPdf (aMaterial,\n"
  "        toLocalSpace (-theRay.Direct, aSpace), toLocalSpace (aLight.xyz, aSpace), aThroughput);\n"
  "\n"
  "      // MIS weight including division by explicit PDF\n"
  "      float aMIS = (aExpPDF == MAXFLOAT) ? 1.f : aExpPDF / (aExpPDF * aExpPDF + aImpPDF * aImpPDF);\n"
  "\n"
  "      vec3 aContrib = aMIS * aParam.rgb /* Le */ * HandleMaterial (\n"
  "          aMaterial, toLocalSpace (aLight.xyz, aSpace), toLocalSpace (-theRay.Direct, aSpace));\n"
  "\n"
  "      if (any (greaterThan (aContrib, MIN_CONTRIBUTION))) // check if light source is important\n"
  "      {\n"
  "        SRay aShadow = SRay (theRay.Origin + aLight.xyz * uSceneEpsilon, aLight.xyz);\n"
  "\n"
  "        aShadow.Origin += aHit.Normal * mix (\n"
  "          -uSceneEpsilon, uSceneEpsilon, step (0.f, dot (aHit.Normal, aLight.xyz)));\n"
  "\n"
  "        float aVisibility = SceneAnyHit (aShadow,\n"
  "          InverseDirection (aLight.xyz), aLight.w == 0.f ? MAXFLOAT : aDistance);\n"
  "\n"
  "        aRadiance += aVisibility * aThroughput * aContrib;\n"
  "      }\n"
  "    }\n"
  "\n"
  "    if (aInMedium) // handle attenuation\n"
  "    {\n"
  "      aThroughput *= exp (-aHit.Time *\n"
  "        aMaterial.Absorption.w * (UNIT - aMaterial.Absorption.rgb));\n"
  "    }\n"
  "\n"
  "    vec3 anInput = UNIT; // sampled input direction\n"
  "\n"
  "    aImpPDF = SampleBsdf (aMaterial,\n"
  "      toLocalSpace (-theRay.Direct, aSpace), anInput, aThroughput, aInMedium);\n"
  "\n"
  "    float aSurvive = 1.f;\n"
  "\n"
  "#ifdef RUSSIAN_ROULETTE\n"
  "    aSurvive = aDepth < 3 ? 1.f : min (dot (LUMA, aThroughput), 0.95f);\n"
  "#endif\n"
  "\n"
  "    if (RandFloat() > aSurvive || all (lessThan (aThroughput, MIN_THROUGHPUT)) || aDepth >= uAccumSamples / FRAME_STEP + step (1.f / M_PI, aImpPDF))\n"
  "    {\n"
  "      aDepth = INVALID_BOUNCES; // terminate path\n"
  "    }\n"
  "\n"
  "#ifdef RUSSIAN_ROULETTE\n"
  "    aThroughput /= aSurvive;\n"
  "#endif\n"
  "\n"
  "    anInput = normalize (fromLocalSpace (anInput, aSpace));\n"
  "\n"
  "    theRay = SRay (theRay.Origin + anInput * uSceneEpsilon +\n"
  "      aHit.Normal * mix (-uSceneEpsilon, uSceneEpsilon, step (0.f, dot (aHit.Normal, anInput))), anInput);\n"
  "\n"
  "    theInverse = InverseDirection (anInput);\n"
  "  }\n"
  "\n"
  "  gl_FragDepth = aRaytraceDepth;\n"
  "\n"
  "  return vec4 (aRadiance, aRaytraceDepth);\n"
  "}\n"
  "\n"
  "#endif\n";
